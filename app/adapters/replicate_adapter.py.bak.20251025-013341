import os
import time
import json
import requests
from pathlib import Path

class ReplicateClient:
    """
    Клиент Replicate с авто-выбором эндпоинта:
    - если задан REPLICATE_MODEL_VERSION -> /v1/predictions (version + input)
    - если не задан -> /v1/models/{owner}/{name}/predictions (только input)
    """
    def __init__(self, out_dir: str):
        self.out_dir = Path(out_dir)
        self.out_dir.mkdir(parents=True, exist_ok=True)

        self.api_token = (os.getenv("REPLICATE_API_TOKEN") or "").strip()
        if not self.api_token:
            raise RuntimeError("REPLICATE_API_TOKEN не задан")

        self.model = (os.getenv("REPLICATE_MODEL") or "tencent/hunyuan-video").strip()
        self.version = (os.getenv("REPLICATE_MODEL_VERSION") or "").strip()

        self.base = "https://api.replicate.com/v1"
        self.timeout = float(os.getenv("REPLICATE_TIMEOUT", "900"))
        self.poll_every = float(os.getenv("REPLICATE_POLL_EVERY", "2.0"))

    def _headers(self):
        return {
            "Authorization": f"Token {self.api_token}",
            "Content-Type": "application/json",
        }

    def _post(self, url: str, payload: dict) -> dict:
        r = requests.post(url, headers=self._headers(), data=json.dumps(payload), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate POST {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _get(self, url: str) -> dict:
        r = requests.get(url, headers=self._headers(), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate GET {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _download(self, url: str) -> str:
        r = requests.get(url, stream=True, timeout=120)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate media GET failed: {r.status_code}")
        out_path = self.out_dir / f"replicate_{int(time.time())}.mp4"
        with open(out_path, "wb") as f:
            for chunk in r.iter_content(1024 * 1024):
                if chunk:
                    f.write(chunk)
        return str(out_path)

    def generate(self, prompt: str, duration: int = 5) -> str:
        # Без картинок — это именно T2V. На i2v ругнёмся сразу, чтобы не ловить 422.
        if "i2v" in self.model and not self.version:
            # даже с версией i2v нужна картинка, так что лучше явно подсказать:
            raise RuntimeError("Вы выбрали i2v-модель, но не передали image. Переключись на t2v или дай image.")

        # Формируем input
        input_payload = {"prompt": prompt, "duration": duration}

        # 1) Если есть version — классический predictions
        if self.version:
            body = {"version": self.version, "input": input_payload}
            pred = self._post(f"{self.base}/predictions", body)
        else:
            # 2) Без version — модельный эндпоинт
            owner, name = self.model.split("/", 1)
            pred = self._post(f"{self.base}/models/{owner}/{name}/predictions", {"input": input_payload})

        get_url = pred.get("urls", {}).get("get")
        if not get_url:
            raise RuntimeError(f"Replicate: нет urls.get в ответе: {pred}")

        t0 = time.time()
        while True:
            p = self._get(get_url)
            status = p.get("status")
            if status in ("succeeded", "failed", "canceled"):
                if status != "succeeded":
                    raise RuntimeError(f"Replicate generation status={status}: {p}")
                output = p.get("output")
                # output бывает строкой (url) или массивом url
                if isinstance(output, list) and output:
                    return self._download(output[-1])
                if isinstance(output, str):
                    return self._download(output)
                raise RuntimeError(f"Replicate: пустой output: {p}")
            if time.time() - t0 > self.timeout:
                raise TimeoutError("Replicate generation timeout")
            time.sleep(self.poll_every)
