sudo tee /opt/content_factory/app/adapters/replicate_adapter.py >/dev/null <<'PY'
import os
import time
import json
import ssl
import http.client
import requests
from pathlib import Path


class ReplicateClient:
    """
    Replicate T2V/i2v клиент.
    - T2V: /v1/predictions (если задан version) или /v1/models/{owner}/{name}/predictions
    - I2V: загрузка файла + strict_reference + negative_prompt
    - Upload: сырой HTTPS multipart с явным Content-Length (обходит chunked/POP баги).
    """
    def __init__(self, out_dir: str):
        self.out_dir = Path(out_dir)
        self.out_dir.mkdir(parents=True, exist_ok=True)

        self.api_token = (os.getenv("REPLICATE_API_TOKEN") or "").strip()
        if not self.api_token:
            raise RuntimeError("REPLICATE_API_TOKEN не задан")

        self.model = (os.getenv("REPLICATE_MODEL") or "wan-video/wan-2.2-t2v-fast").strip()
        self.version = (os.getenv("REPLICATE_MODEL_VERSION") or "").strip()

        self.base = "https://api.replicate.com/v1"
        self.timeout = float(os.getenv("REPLICATE_TIMEOUT", "180"))
        self.poll_every = float(os.getenv("REPLICATE_POLL_EVERY", "2.0"))

    # --- HTTP helpers ---

    def _headers(self):
        return {
            "Authorization": f"Token {self.api_token}",
            "Content-Type": "application/json",
        }

    def _post(self, url: str, payload: dict) -> dict:
        r = requests.post(url, headers=self._headers(), data=json.dumps(payload), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate POST {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _get(self, url: str) -> dict:
        r = requests.get(url, headers=self._headers(), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate GET {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _download(self, url: str) -> str:
        r = requests.get(url, stream=True, timeout=120)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate media GET failed: {r.status_code}")
        out_path = self.out_dir / f"replicate_{int(time.time())}.mp4"
        with open(out_path, "wb") as f:
            for chunk in r.iter_content(1024 * 1024):
                if chunk:
                    f.write(chunk)
        return str(out_path)

    def _upload_file(self, path: str) -> str:
        """
        Upload без requests: сырой HTTPS multipart с явным Content-Length.
        Обходит chunked/transfer артефакты и Cloudflare POP.
        """
        ip = Path(path)
        if (not ip.exists()) or ip.stat().st_size == 0:
            raise RuntimeError(f"Replicate file upload: local file empty or missing: {path}")

        filename = ip.name
        mime = "image/jpeg"  # мы заранее конвертим в JPEG в ui-слое
        boundary = f"----cf{int(time.time())}"

        with open(path, "rb") as f:
            file_data = f.read()

        pre = (
            f"--{boundary}\r\n"
            f'Content-Disposition: form-data; name="file"; filename="{filename}"\r\n'
            f"Content-Type: {mime}\r\n\r\n"
        ).encode("utf-8")
        post = f"\r\n--{boundary}--\r\n".encode("utf-8")
        body = pre + file_data + post

        ctx = ssl.create_default_context()
        conn = http.client.HTTPSConnection("api.replicate.com", 443, context=ctx, timeout=90)
        conn.putrequest("POST", "/v1/files")
        conn.putheader("Authorization", f"Token {self.api_token}")
        conn.putheader("Content-Type", f"multipart/form-data; boundary={boundary}")
        conn.putheader("Content-Length", str(len(body)))
        conn.endheaders()
        conn.send(body)

        resp = conn.getresponse()
        data = resp.read()
        conn.close()

        if resp.status >= 400:
            raise RuntimeError(f"Replicate file upload failed: {resp.status} {data.decode('utf-8','ignore')}")

        try:
            j = json.loads(data.decode("utf-8"))
        except Exception:
            raise RuntimeError(f"Replicate file upload: non-JSON response: {data[:200]!r}")

        url = j.get("url")
        if not url:
            raise RuntimeError(f"Replicate file upload: no 'url' in response: {j}")
        return url

    # --- POLLING ---

    def _poll_until_done(self, get_url: str) -> str:
        t0 = time.time()
        while True:
            p = self._get(get_url)
            status = p.get("status")
            if status in ("succeeded", "failed", "canceled"):
                if status != "succeeded":
                    raise RuntimeError(f"Replicate generation status={status}: {p}")
                output = p.get("output")
                if isinstance(output, list) and output:
                    return self._download(output[-1])
                if isinstance(output, str) and output:
                    return self._download(output)
                raise RuntimeError(f"Replicate: empty output: {p}")
            if time.time() - t0 > self.timeout:
                raise TimeoutError("Replicate generation timeout")
            time.sleep(self.poll_every)

    # --- T2V ---

    def generate(self, prompt: str, duration: int = 5) -> str:
        input_payload = {"prompt": prompt, "duration": duration}
        if self.version:
            body = {"version": self.version, "input": input_payload}
            pred = self._post(f"{self.base}/predictions", body)
        else:
            owner, name = self.model.split("/", 1)
            pred = self._post(f"{self.base}/models/{owner}/{name}/predictions", {"input": input_payload})
        get_url = pred.get("urls", {}).get("get")
        if not get_url:
            raise RuntimeError(f"Replicate: нет urls.get в ответе: {pred}")
        return self._poll_until_done(get_url)

    # --- I2V ---

    def generate_from_image(self, image_path: str, prompt: str, duration: int = 5) -> str:
        model_i2v = (os.getenv("REPLICATE_MODEL_I2V") or "wan-video/wan-2.2-i2v-fast").strip()
        owner, name = model_i2v.split("/", 1)

        img_url = self._upload_file(image_path)
        neg_base = (os.getenv("I2V_NEGATIVE_BASE") or "").strip()
        strict_on = (os.getenv("I2V_STRICT_REFERENCE", "1").strip() not in ("0", "false", "False"))

        input_payload = {
            "image": img_url,
            "prompt": (prompt or "").strip(),
            "duration": duration,
        }
        if neg_base:
            input_payload["negative_prompt"] = neg_base
        if strict_on:
            input_payload["strict_reference"] = True

        pred = self._post(f"{self.base}/models/{owner}/{name}/predictions", {"input": input_payload})
        get_url = pred.get("urls", {}).get("get")
        if not get_url:
            raise RuntimeError(f"Replicate I2V: нет urls.get в ответе: {pred}")
        return self._poll_until_done(get_url)
PY

sudo systemctl restart content-factory.service
journalctl -u content-factory.service -n 30 -f
