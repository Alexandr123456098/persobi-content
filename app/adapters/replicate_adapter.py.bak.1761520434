import os
import time
import json
import ssl
import http.client
import requests
from pathlib import Path

class ReplicateClient:
    """
    Replicate T2V/i2v клиент.
    - T2V: /v1/predictions (если задан version) или /v1/models/{owner}/{name}/predictions
    - I2V: upload файла -> strict_reference / negative_prompt.
    - Upload: несколько стратегий (requests + сырой HTTPS multipart) с ретраями.
      Если API вернул только id (без url), используем replicate://files/<id>.
    """
    def __init__(self, out_dir: str):
        self.out_dir = Path(out_dir)
        self.out_dir.mkdir(parents=True, exist_ok=True)

        self.api_token = (os.getenv("REPLICATE_API_TOKEN") or "").strip()
        if not self.api_token:
            raise RuntimeError("REPLICATE_API_TOKEN не задан")

        self.model = (os.getenv("REPLICATE_MODEL") or "wan-video/wan-2.2-t2v-fast").strip()
        self.version = (os.getenv("REPLICATE_MODEL_VERSION") or "").strip()

        self.base = "https://api.replicate.com/v1"
        self.timeout = float(os.getenv("REPLICATE_TIMEOUT", "180"))
        self.poll_every = float(os.getenv("REPLICATE_POLL_EVERY", "2.0"))

    # --- HTTP helpers ---

    def _headers(self):
        return {
            "Authorization": f"Token {self.api_token}",
            "Content-Type": "application/json",
        }

    def _post(self, url: str, payload: dict) -> dict:
        r = requests.post(url, headers=self._headers(), data=json.dumps(payload), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate POST {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _get(self, url: str) -> dict:
        r = requests.get(url, headers=self._headers(), timeout=30)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate GET {url} failed: {r.status_code} {r.text}")
        return r.json()

    def _download(self, url: str) -> str:
        r = requests.get(url, stream=True, timeout=120)
        if r.status_code >= 400:
            raise RuntimeError(f"Replicate media GET failed: {r.status_code}")
        out_path = self.out_dir / f"replicate_{int(time.time())}.mp4"
        with open(out_path, "wb") as f:
            for chunk in r.iter_content(1024 * 1024):
                if chunk:
                    f.write(chunk)
        return str(out_path)

    # --- UPLOAD (многоступенчатый) ---

    def _upload_file(self, path: str) -> str:
        """
        Стратегии:
          1) requests multipart с (filename, image/jpeg)
          2) requests multipart «как есть»
          3) сырой http.client multipart c полем name="file"
          4) сырой http.client multipart c полем name="content"

        Возвращаем либо публичный url (replicate.delivery), либо replicate://files/<id>.
        """
        ip = Path(path)
        if (not ip.exists()) or ip.stat().st_size == 0:
            raise RuntimeError(f"Replicate file upload: local file empty or missing: {path}")

        files_url = f"{self.base}/files"

        def parse_upload_response(status: int, headers: dict, data: bytes) -> str | None:
            # ждем JSON; может быть {"url": "..."} ИЛИ {"id": "...", ...}
            if status >= 400:
                return None
            try:
                j = json.loads(data.decode("utf-8"))
            except Exception:
                return None
            url = j.get("url")
            if url:
                return url
            _id = j.get("id")
            if _id:
                return f"replicate://files/{_id}"
            return None

        # 1) requests: явное имя и тип
        for attempt in (1, 2):
            try:
                with open(path, "rb") as f:
                    r = requests.post(
                        files_url,
                        headers={"Authorization": f"Token {self.api_token}"},
                        files={"file": (ip.name, f, "image/jpeg")},
                        timeout=90,
                    )
                res = parse_upload_response(r.status_code, r.headers, r.content)
                if res:
                    return res
            except Exception:
                pass
            time.sleep(0.5 * attempt)

        # 2) requests: «как есть»
        for attempt in (1, 2):
            try:
                with open(path, "rb") as f:
                    r = requests.post(
                        files_url,
                        headers={"Authorization": f"Token {self.api_token}"},
                        files={"file": f},
                        timeout=90,
                    )
                res = parse_upload_response(r.status_code, r.headers, r.content)
                if res:
                    return res
            except Exception:
                pass
            time.sleep(0.5 * attempt)

        # 3–4) сырой multipart через http.client
        def raw_upload(field_name: str) -> str | None:
            boundary = f"----cf{int(time.time())}"
            pre = (
                f"--{boundary}\r\n"
                f'Content-Disposition: form-data; name="{field_name}"; filename="{ip.name}"\r\n'
                f"Content-Type: image/jpeg\r\n\r\n"
            ).encode("utf-8")
            post = f"\r\n--{boundary}--\r\n".encode("utf-8")
            body = pre + ip.read_bytes() + post

            ctx = ssl.create_default_context()
            conn = http.client.HTTPSConnection("api.replicate.com", 443, context=ctx, timeout=90)
            conn.putrequest("POST", "/v1/files")
            conn.putheader("Authorization", f"Token {self.api_token}")
            conn.putheader("Content-Type", f"multipart/form-data; boundary={boundary}")
            conn.putheader("Content-Length", str(len(body)))
            conn.putheader("Accept", "application/json")
            conn.putheader("Connection", "close")
            conn.endheaders()
            conn.send(body)
            resp = conn.getresponse()
            data = resp.read()
            conn.close()
            return parse_upload_response(resp.status, {"content-type": resp.getheader("content-type","")}, data)

        for fname in ("file", "content"):
            for attempt in (1, 2):
                res = raw_upload(fname)
                if res:
                    return res
                time.sleep(0.5 * attempt)

        raise RuntimeError("Replicate file upload failed: all strategies returned no URL/id")

    # --- POLLING ---

    def _poll_until_done(self, get_url: str) -> str:
        t0 = time.time()
        while True:
            p = self._get(get_url)
            status = p.get("status")
            if status in ("succeeded", "failed", "canceled"):
                if status != "succeeded":
                    raise RuntimeError(f"Replicate generation status={status}: {p}")
                output = p.get("output")
                if isinstance(output, list) and output:
                    return self._download(output[-1])
                if isinstance(output, str) and output:
                    return self._download(output)
                raise RuntimeError(f"Replicate: empty output: {p}")
            if time.time() - t0 > self.timeout:
                raise TimeoutError("Replicate generation timeout")
            time.sleep(self.poll_every)

    # --- T2V ---

    def generate(self, prompt: str, duration: int = 5) -> str:
        input_payload = {"prompt": prompt, "duration": duration}
        if self.version:
            body = {"version": self.version, "input": input_payload}
            pred = self._post(f"{self.base}/predictions", body)
        else:
            owner, name = self.model.split("/", 1)
            pred = self._post(f"{self.base}/models/{owner}/{name}/predictions", {"input": input_payload})
        get_url = pred.get("urls", {}).get("get")
        if not get_url:
            raise RuntimeError(f"Replicate: нет urls.get в ответе: {pred}")
        return self._poll_until_done(get_url)

    # --- I2V ---

    def generate_from_image(self, image_path: str, prompt: str, duration: int = 5) -> str:
        model_i2v = (os.getenv("REPLICATE_MODEL_I2V") or "wan-video/wan-2.2-i2v-fast").strip()
        owner, name = model_i2v.split("/", 1)

        img_ref = self._upload_file(image_path)  # url ИЛИ replicate://files/<id>
        neg_base = (os.getenv("I2V_NEGATIVE_BASE") or "").strip()
        strict_on = (os.getenv("I2V_STRICT_REFERENCE", "1").strip() not in ("0", "false", "False"))

        input_payload = {
            "image": img_ref,
            "prompt": (prompt or "").strip(),
            "duration": duration,
        }
        if neg_base:
            input_payload["negative_prompt"] = neg_base
        if strict_on:
            input_payload["strict_reference"] = True

        pred = self._post(f"{self.base}/models/{owner}/{name}/predictions", {"input": input_payload})
        get_url = pred.get("urls", {}).get("get")
        if not get_url:
            raise RuntimeError(f"Replicate I2V: нет urls.get в ответе: {pred}")
        return self._poll_until_done(get_url)
