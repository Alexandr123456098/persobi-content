# /opt/content_factory/app/bot.py
# -*- coding: utf-8 -*-
import os, asyncio, logging
from aiogram import Bot, Dispatcher, F
from aiogram.filters import Command
from aiogram.types import Message, CallbackQuery, FSInputFile, InlineKeyboardMarkup, InlineKeyboardButton

from adapters.luma_adapter import render_4k
from adapters.tts_adapter import voiceover_video

BOT_TOKEN = os.getenv("BOT_TOKEN", "").strip()
REPLICATE_API_TOKEN = os.getenv("REPLICATE_API_TOKEN", "").strip()
OUT_DIR = os.getenv("OUT_DIR", "/opt/content_factory/out").strip()

# –¢–≤–æ–∏ —Ñ—É–Ω–∫—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –µ—Å—Ç—å (–∑–∞–≥–ª—É—à–∫–∏ —Ç—É—Ç –¥–ª—è –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞):
# - wan_t2v(prompt, out_dir) -> str|None
# - wan_i2v(image_url, prompt, out_dir) -> str|None
from app.adapters.wan_adapter import wan_t2v, wan_i2v  # –µ—Å–ª–∏ —É —Ç–µ–±—è –¥—Ä—É–≥–æ–π –ø—É—Ç—å ‚Äî –ø–æ–ø—Ä–∞–≤—å –∏–º–ø–æ—Ä—Ç

logging.basicConfig(level=logging.INFO)
log = logging.getLogger("bot")

bot = Bot(BOT_TOKEN)
dp = Dispatcher()

# —Å–æ—Å—Ç–æ—è–Ω–∏—è –Ω–∞ —á–∞—Ç
last_prompt: dict[int, str] = {}
last_director_prompt: dict[int, str] = {}
last_video_path: dict[int, str] = {}

# –ó–∞–≥–ª—É—à–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ ¬´—Ä–µ–∂–∏—Å—Å—ë—Ä—Å–∫–æ–≥–æ –ø—Ä–æ–º–ø—Ç–∞¬ª.
# –ï—Å–ª–∏ –Ω–µ—Ç OPENAI_API_KEY ‚Äî –ø—Ä–æ—Å—Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –≤—Ö–æ–¥–Ω–æ–π —Ç–µ–∫—Å—Ç.
def make_director_prompt(text: str) -> str:
    return text

def _kb():
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üîÅ –°–¥–µ–ª–∞—Ç—å 4K –≤ Luma", callback_data="upscale_luma"),
                InlineKeyboardButton(text="üîä –û–∑–≤—É—á–∏—Ç—å", callback_data="voiceover")
            ]
        ]
    )

async def _tg_file_url(bot: Bot, file_id: str) -> str:
    f = await bot.get_file(file_id)
    return f"https://api.telegram.org/file/bot{BOT_TOKEN}/{f.file_path}"

@dp.message(Command("start"))
async def on_start(m: Message):
    await m.answer("–Ø —Å–æ–±–µ—Ä—É —Ä–µ–∂–∏—Å—Å—ë—Ä—Å–∫–∏–π –ø—Ä–æ–º–ø—Ç –∏ —Å–¥–µ–ª–∞—é —á–µ—Ä–Ω–æ–≤–∏–∫. –ù–∞–ø–∏—à–∏ –∏–¥–µ—é –∏–ª–∏ –ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ.")

@dp.message(F.photo)
async def on_photo(m: Message):
    chat_id = m.chat.id
    prompt = last_prompt.get(chat_id, "–∞–∫–∫—É—Ä–∞—Ç–Ω–æ–µ –¥–≤–∏–∂–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã")
    director = make_director_prompt(prompt)
    last_director_prompt[chat_id] = director

    file_id = m.photo[-1].file_id
    img_url = await _tg_file_url(bot, file_id)

    await m.answer("–î–µ–ª–∞—é —á–µ—Ä–Ω–æ–≤–∏–∫ (WAN i2v)‚Ä¶")
    fp = await wan_i2v(img_url, director, OUT_DIR)
    if not fp:
        await m.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –≤–∏–¥–µ–æ –≤ WAN i2v. –ü–æ–ø—Ä–æ–±—É–π –¥—Ä—É–≥–æ–µ —Ñ–æ—Ç–æ/—Ç–µ–∫—Å—Ç.")
        return

    last_video_path[chat_id] = fp
    caption = "–ß–µ—Ä–Ω–æ–≤–∏–∫\n\nüé¨ –ü—Ä–æ–º–ø—Ç:\n" + director
    await m.answer_video(video=FSInputFile(fp), caption=caption, reply_markup=_kb())

@dp.message(F.text.len() > 0)
async def on_text(m: Message):
    chat_id = m.chat.id
    text = m.text.strip()
    last_prompt[chat_id] = text
    director = make_director_prompt(text)
    last_director_prompt[chat_id] = director

    await m.answer("–û–∫–µ–π. –†–µ–Ω–¥–µ—Ä—é –æ–¥–Ω–æ –≤–∏–¥–µ–æ (WAN t2v)‚Ä¶")
    fp = await wan_t2v(director, OUT_DIR)
    if not fp:
        await m.answer("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–¥–µ–ª–∞—Ç—å —á–µ—Ä–Ω–æ–≤–∏–∫ –≤ WAN t2v. –ü–æ–ø—Ä–æ–±—É–π —É–ø—Ä–æ—Å—Ç–∏—Ç—å –ø—Ä–æ–º–ø—Ç –∏–ª–∏ –ø—Ä–∏—à–ª–∏ —Ñ–æ—Ç–æ.")
        return

    last_video_path[chat_id] = fp
    caption = "–ß–µ—Ä–Ω–æ–≤–∏–∫\n\nüé¨ –ü—Ä–æ–º–ø—Ç:\n" + director
    await m.answer_video(video=FSInputFile(fp), caption=caption, reply_markup=_kb())

@dp.message(Command("prompt"))
async def cmd_prompt(m: Message):
    p = last_director_prompt.get(m.chat.id)
    if not p:
        await m.answer("–ü—Ä–æ–º–ø—Ç –ø–æ–∫–∞ –ø—É—Å—Ç. –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π —á–µ—Ä–Ω–æ–≤–∏–∫.")
        return
    await m.answer(f"üé¨ –¢–µ–∫—É—â–∏–π –ø—Ä–æ–º–ø—Ç:\n{p}")

@dp.callback_query(F.data == "upscale_luma")
async def on_upscale(cb: CallbackQuery):
    chat_id = cb.message.chat.id
    p = last_director_prompt.get(chat_id)
    if not p:
        await cb.answer("–ù–µ—Ç –ø—Ä–æ–º–ø—Ç–∞ –¥–ª—è Luma", show_alert=True); return
    await cb.answer("–ó–∞–ø—É—Å–∫–∞—é Luma 4K‚Ä¶")
    await cb.message.answer("–ü—Ä–µ–º–∏—É–º-—Ä–µ–Ω–¥–µ—Ä –≤ Luma 4K. –ñ–¥—É —Ä–µ–∑—É–ª—å—Ç–∞—Ç‚Ä¶")
    url = await asyncio.to_thread(render_4k, p, "16:9")
    if not url:
        await cb.message.answer("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å/–¥–æ–∂–¥–∞—Ç—å—Å—è Luma 4K. –ü—Ä–æ–≤–µ—Ä—å –∫–ª—é—á –∏ –±–∞–ª–∞–Ω—Å.")
        return
    # Telegram –ø—Ä–∏–Ω–∏–º–∞–µ—Ç HTTP URL –Ω–∞ mp4 –Ω–∞–ø—Ä—è–º—É—é
    await cb.message.answer_video(video=url, caption="Luma 4K ‚úÖ")

@dp.callback_query(F.data == "voiceover")
async def on_voiceover(cb: CallbackQuery):
    chat_id = cb.message.chat.id
    fp = last_video_path.get(chat_id)
    p = last_director_prompt.get(chat_id)
    if not fp or not p:
        await cb.answer("–ù–µ—á–µ–≥–æ –æ–∑–≤—É—á–∏–≤–∞—Ç—å. –°–Ω–∞—á–∞–ª–∞ —Å–¥–µ–ª–∞–π —á–µ—Ä–Ω–æ–≤–∏–∫.", show_alert=True); return
    await cb.answer("–î–µ–ª–∞—é –æ–∑–≤—É—á–∫—É‚Ä¶")
    await cb.message.answer("–°–∏–Ω—Ç–µ–∑ –≥–æ–ª–æ—Å–∞ –∏ —Å–∫–ª–µ–π–∫–∞‚Ä¶")
    try:
        out_fp = await asyncio.to_thread(voiceover_video, fp, p)
    except Exception as e:
        await cb.message.answer(f"–û–∑–≤—É—á–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å: {e}")
        return
    await cb.message.answer_video(video=FSInputFile(out_fp), caption="–û–∑–≤—É—á–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è ‚úÖ")

async def main():
    log.info(f"ENV: BOT_TOKEN={'set' if BOT_TOKEN else 'EMPTY'}, REPLICATE={'set' if REPLICATE_API_TOKEN else 'EMPTY'}")
    await dp.start_polling(bot)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except (KeyboardInterrupt, SystemExit):
        log.info("Bot stopped")
